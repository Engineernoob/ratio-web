/**
 * Memory AI - Insight Curator Engine
 * 
 * Analyzes all user data to generate insights, recommendations, and memory cards.
 * Integrates with Memoria, Bibliotheca, Ars Rationis, Laboratorivm, and Scholarivm.
 */

import fs from "fs";
import path from "path";
import type { MemoryCard } from "@/lib/memoria/types";
import { loadCards, createCard } from "@/lib/memoria/storage";
import { loadHighlights } from "@/lib/notes";
import { getBookManifest, getChapter } from "@/lib/books";
import { getAllBookIds } from "@/lib/books";
import { loadFallacies } from "@/lib/logic/fallacies";
import { loadUserState } from "@/lib/mentor/state";
import type { Puzzle } from "@/lib/puzzles/types";

const DATA_DIR = path.join(process.cwd(), "data");
const BOOKS_DIR = path.join(DATA_DIR, "books");
const PUZZLES_DIR = path.join(DATA_DIR, "puzzles");

export interface WeaknessReport {
  lowEaseCards: Array<{
    id: string;
    title: string;
    ease: number;
    errorRate: number;
    recommendation: string;
  }>;
  fallacyErrors: Array<{
    type: string;
    count: number;
    examples: string[];
    recommendation: string;
  }>;
  puzzleMistakes: Array<{
    puzzleId: string;
    type: string;
    attempts: number;
    recommendation: string;
  }>;
  weakConcepts: Array<{
    concept: string;
    sources: string[];
    frequency: number;
    recommendation: string;
  }>;
}

export interface UnifyingInsight {
  id: string;
  title: string;
  description: string;
  sources: string[];
  relatedCards: string[];
  confidence: number;
}

export interface DailyRecommendation {
  concepts: Array<{
    cardId: string;
    title: string;
    reason: string;
  }>;
  chapters: Array<{
    bookId: string;
    chapterId: string;
    title: string;
    reason: string;
  }>;
  puzzles: Array<{
    puzzleId: string;
    type: string;
    reason: string;
  }>;
  generatedAt: string;
}

export interface InsightSummary {
  strengths: string[];
  weaknesses: WeaknessReport;
  unifyingInsights: UnifyingInsight[];
  dailyRecommendation: DailyRecommendation;
  autoGeneratedCards: number;
  totalAnalysis: {
    cardsAnalyzed: number;
    highlightsAnalyzed: number;
    chaptersAnalyzed: number;
    notesAnalyzed: number;
  };
}

/**
 * Main curator function - performs comprehensive analysis
 */
export async function curateInsights(): Promise<InsightSummary> {
  // Load all data sources
  const cards = loadCards();
  const allHighlights = loadAllHighlights();
  const allNotes = loadAllNotes();
  const chapters = loadAllChapters();
  const userState = loadUserState();
  const fallacies = loadFallacies();

  // Analyze memoria performance
  const weaknessReport = analyzeWeaknesses(cards, userState, fallacies);

  // Cluster weak concepts
  const weakConcepts = clusterWeakConcepts(cards, allHighlights, allNotes);

  // Generate new memory cards
  const newCards = await generateMemoryCards(allHighlights, chapters, allNotes);
  
  // Save new cards
  for (const card of newCards) {
    try {
      createCard(card);
    } catch (error) {
      // Card might already exist, skip
      console.log(`Card ${card.id} already exists, skipping`);
    }
  }

  // Find recurring ideas and create unifying insights
  const unifyingInsights = generateUnifyingInsights(cards, allHighlights, chapters);

  // Generate daily recommendations
  const dailyRecommendation = generateDailyRecommendation(
    cards,
    weaknessReport,
    chapters,
    userState
  );

  // Identify strengths
  const strengths = identifyStrengths(cards, userState);

  return {
    strengths,
    weaknesses: weaknessReport,
    unifyingInsights,
    dailyRecommendation,
    autoGeneratedCards: newCards.length,
    totalAnalysis: {
      cardsAnalyzed: cards.length,
      highlightsAnalyzed: allHighlights.length,
      chaptersAnalyzed: chapters.length,
      notesAnalyzed: allNotes.length,
    },
  };
}

/**
 * Analyze weaknesses across all systems
 */
function analyzeWeaknesses(
  cards: MemoryCard[],
  userState: any,
  fallacies: any[]
): WeaknessReport {
  // Find cards with low ease factor
  const lowEaseCards = cards
    .filter((card) => card.ease < 2.0 && card.totalReviews > 0)
    .map((card) => ({
      id: card.id,
      title: card.title,
      ease: card.ease,
      errorRate: card.totalReviews > 0
        ? (card.totalReviews - card.consecutiveCorrect) / card.totalReviews
        : 0,
      recommendation: generateCardRecommendation(card),
    }))
    .sort((a, b) => a.ease - b.ease)
    .slice(0, 10);

  // Analyze fallacy errors
  const fallacyErrors = (userState.fallacyErrors || []).map((error: any) => ({
    type: error.type,
    count: error.count,
    examples: [error.context],
    recommendation: generateFallacyRecommendation(error.type, fallacies),
  }));

  // Analyze puzzle mistakes
  const puzzleMistakes = (userState.failedPuzzles || []).map((puzzle: any) => ({
    puzzleId: puzzle.id,
    type: puzzle.type,
    attempts: puzzle.attempts,
    recommendation: generatePuzzleRecommendation(puzzle.type),
  }));

  // Cluster weak concepts
  const weakConcepts = clusterWeakConcepts(cards, [], []);

  return {
    lowEaseCards,
    fallacyErrors,
    puzzleMistakes,
    weakConcepts,
  };
}

/**
 * Cluster weak concepts across multiple sources
 */
function clusterWeakConcepts(
  cards: MemoryCard[],
  highlights: any[],
  notes: any[]
): Array<{
  concept: string;
  sources: string[];
  frequency: number;
  recommendation: string;
}> {
  const conceptMap = new Map<string, { sources: Set<string>; count: number }>();

  // Extract concepts from cards
  for (const card of cards.filter((c) => c.ease < 2.0)) {
    const keywords = extractKeywords(card.title + " " + card.content);
    for (const keyword of keywords) {
      if (!conceptMap.has(keyword)) {
        conceptMap.set(keyword, { sources: new Set(), count: 0 });
      }
      const entry = conceptMap.get(keyword)!;
      entry.sources.add(`card:${card.id}`);
      entry.count++;
    }
  }

  // Extract concepts from highlights
  for (const highlight of highlights) {
    const keywords = extractKeywords(highlight.text);
    for (const keyword of keywords) {
      if (!conceptMap.has(keyword)) {
        conceptMap.set(keyword, { sources: new Set(), count: 0 });
      }
      const entry = conceptMap.get(keyword)!;
      entry.sources.add(`highlight:${highlight.id}`);
      entry.count++;
    }
  }

  // Extract concepts from notes
  for (const note of notes) {
    const keywords = extractKeywords(note.text);
    for (const keyword of keywords) {
      if (!conceptMap.has(keyword)) {
        conceptMap.set(keyword, { sources: new Set(), count: 0 });
      }
      const entry = conceptMap.get(keyword)!;
      entry.sources.add(`note:${note.id}`);
      entry.count++;
    }
  }

  // Convert to array and filter by frequency
  return Array.from(conceptMap.entries())
    .filter(([_, data]) => data.count >= 2)
    .map(([concept, data]) => ({
      concept,
      sources: Array.from(data.sources),
      frequency: data.count,
      recommendation: `Review and practice the concept "${concept}" across ${data.sources.size} sources.`,
    }))
    .sort((a, b) => b.frequency - a.frequency)
    .slice(0, 10);
}

/**
 * Generate memory cards from highlights, chapters, and notes
 */
async function generateMemoryCards(
  highlights: any[],
  chapters: any[],
  notes: any[]
): Promise<MemoryCard[]> {
  const newCards: MemoryCard[] = [];
  const today = new Date().toISOString().split("T")[0];

  // Generate cards from highlights
  for (const highlight of highlights) {
    if (highlight.text.length > 20 && highlight.text.length < 500) {
      const keywords = extractKeywords(highlight.text);
      const title = keywords.slice(0, 3).join(" ") || "Key Insight";
      
      const cardId = `ai-highlight-${highlight.id}`;
      
      // Check if card already exists
      const existingCards = loadCards();
      if (existingCards.find((c) => c.id === cardId)) {
        continue;
      }

      newCards.push({
        id: cardId,
        title,
        content: highlight.text,
        question: `What is the key insight from: ${title}?`,
        answer: highlight.text.substring(0, 200),
        source: "bibliotheca",
        sourceId: highlight.bookId,
        sourceMetadata: {
          page: highlight.pageNumber,
          chapterId: highlight.chapterId,
        },
        stage: "new",
        ease: 2.5,
        interval: 0,
        due: today,
        reps: 0,
        createdAt: today,
        consecutiveCorrect: 0,
        totalReviews: 0,
        tags: ["ai-generated", "highlight", ...(highlight.tags || [])],
      });
    }
  }

  // Generate cards from chapter key ideas
  for (const chapter of chapters) {
    if (chapter.keyIdeas && Array.isArray(chapter.keyIdeas)) {
      for (let i = 0; i < chapter.keyIdeas.length; i++) {
        const idea = chapter.keyIdeas[i];
        const cardId = `ai-chapter-${chapter.bookId}-${chapter.chapterId}-${i}`;
        
        const existingCards = loadCards();
        if (existingCards.find((c) => c.id === cardId)) {
          continue;
        }

        newCards.push({
          id: cardId,
          title: `Key Idea: ${chapter.title}`,
          content: idea,
          question: `What is the key idea from ${chapter.title}?`,
          answer: idea,
          source: "bibliotheca",
          sourceId: chapter.bookId,
          sourceMetadata: {
            chapterId: chapter.chapterId,
            chapterTitle: chapter.title,
          },
          stage: "new",
          ease: 2.5,
          interval: 0,
          due: today,
          reps: 0,
          createdAt: today,
          consecutiveCorrect: 0,
          totalReviews: 0,
          tags: ["ai-generated", "chapter", "key-idea"],
        });
      }
    }
  }

  // Generate cards from notes
  for (const note of notes) {
    if (note.text.length > 30 && note.text.length < 300) {
      const cardId = `ai-note-${note.id}`;
      
      const existingCards = loadCards();
      if (existingCards.find((c) => c.id === cardId)) {
        continue;
      }

      const keywords = extractKeywords(note.text);
      const title = keywords.slice(0, 3).join(" ") || "Note";

      newCards.push({
        id: cardId,
        title,
        content: note.text,
        question: `What did you note about: ${title}?`,
        answer: note.text,
        source: "bibliotheca",
        sourceId: note.bookId,
        sourceMetadata: {
          chapterId: note.chapterId,
        },
        stage: "new",
        ease: 2.5,
        interval: 0,
        due: today,
        reps: 0,
        createdAt: today,
        consecutiveCorrect: 0,
        totalReviews: 0,
        tags: ["ai-generated", "note"],
      });
    }
  }

  return newCards;
}

/**
 * Generate unifying insights from recurring ideas
 */
function generateUnifyingInsights(
  cards: MemoryCard[],
  highlights: any[],
  chapters: any[]
): UnifyingInsight[] {
  const ideaMap = new Map<string, { sources: Set<string>; texts: string[] }>();

  // Collect ideas from all sources
  const allTexts = [
    ...cards.map((c) => c.content),
    ...highlights.map((h) => h.text),
    ...chapters.map((ch) => ch.summary || ""),
  ];

  // Extract and cluster similar ideas
  for (const text of allTexts) {
    const keywords = extractKeywords(text);
    const keyPhrase = keywords.slice(0, 4).join(" ");
    
    if (keyPhrase.length > 10) {
      if (!ideaMap.has(keyPhrase)) {
        ideaMap.set(keyPhrase, { sources: new Set(), texts: [] });
      }
      const entry = ideaMap.get(keyPhrase)!;
      entry.texts.push(text.substring(0, 200));
      entry.sources.add("mixed");
    }
  }

  // Convert to insights
  return Array.from(ideaMap.entries())
    .filter(([_, data]) => data.texts.length >= 2)
    .map(([phrase, data], index) => ({
      id: `insight-${index}`,
      title: `Unifying Insight: ${phrase}`,
      description: data.texts[0] + "...",
      sources: Array.from(data.sources),
      relatedCards: cards
        .filter((c) => c.content.includes(phrase))
        .map((c) => c.id)
        .slice(0, 5),
      confidence: Math.min(data.texts.length / 5, 1.0),
    }))
    .sort((a, b) => b.confidence - a.confidence)
    .slice(0, 10);
}

/**
 * Generate daily recommendations
 */
function generateDailyRecommendation(
  cards: MemoryCard[],
  weaknessReport: WeaknessReport,
  chapters: any[],
  userState: any
): DailyRecommendation {
  const today = new Date().toISOString().split("T")[0];

  // Recommend 3 weak concepts to study
  const concepts = weaknessReport.lowEaseCards
    .slice(0, 3)
    .map((card) => ({
      cardId: card.id,
      title: card.title,
      reason: card.recommendation,
    }));

  // Recommend chapters to revisit
  const chaptersToReview = chapters
    .filter((ch) => {
      // Find if this chapter has weak concepts
      return weaknessReport.weakConcepts.some((wc) =>
        ch.keyIdeas?.some((idea: string) => idea.includes(wc.concept))
      );
    })
    .slice(0, 3)
    .map((ch) => ({
      bookId: ch.bookId,
      chapterId: ch.chapterId,
      title: ch.title,
      reason: `Contains concepts you're struggling with`,
    }));

  // Recommend puzzle types based on mistakes
  const puzzleTypes = new Set(
    weaknessReport.puzzleMistakes.map((p) => p.type)
  );
  const puzzles = Array.from(puzzleTypes)
    .slice(0, 3)
    .map((type) => ({
      puzzleId: `recommended-${type}`,
      type,
      reason: `Practice ${type} puzzles to improve`,
    }));

  return {
    concepts,
    chapters: chaptersToReview,
    puzzles,
    generatedAt: today,
  };
}

/**
 * Identify user strengths
 */
function identifyStrengths(cards: MemoryCard[], userState: any): string[] {
  const strengths: string[] = [];

  // High ease cards
  const strongCards = cards.filter(
    (c) => c.ease >= 2.3 && c.totalReviews >= 3
  );
  if (strongCards.length > 0) {
    strengths.push(
      `Mastered ${strongCards.length} concepts with high retention`
    );
  }

  // Consistent review streak
  const highStreakCards = cards.filter((c) => c.consecutiveCorrect >= 5);
  if (highStreakCards.length > 0) {
    strengths.push(
      `Maintaining ${highStreakCards.length} concepts with 5+ correct streak`
    );
  }

  // Good memoria accuracy
  if (userState.metrics?.memoriaAccuracy > 80) {
    strengths.push("High memoria accuracy (>80%)");
  }

  // Book progress
  if (userState.booksInProgress?.length > 0) {
    const avgProgress =
      userState.booksInProgress.reduce(
        (sum: number, b: any) => sum + b.progress,
        0
      ) / userState.booksInProgress.length;
    if (avgProgress > 0.5) {
      strengths.push(`Making good progress through ${userState.booksInProgress.length} books`);
    }
  }

  return strengths;
}

/**
 * Helper functions
 */

function loadAllHighlights(): any[] {
  const highlights: any[] = [];
  const notesDir = path.join(DATA_DIR, "notes");

  if (!fs.existsSync(notesDir)) {
    return highlights;
  }

  const noteFiles = fs.readdirSync(notesDir);
  for (const file of noteFiles) {
    if (file.endsWith(".json")) {
      const bookId = file.replace(".json", "");
      try {
        const bookHighlights = loadHighlights(bookId);
        highlights.push(...bookHighlights);
      } catch (error) {
        console.error(`Error loading highlights for ${bookId}:`, error);
      }
    }
  }

  return highlights;
}

function loadAllNotes(): any[] {
  // Notes are stored as highlights with "note" tag
  return loadAllHighlights().filter((h) => h.tags?.includes("note"));
}

function loadAllChapters(): any[] {
  const chapters: any[] = [];
  const bookIds = getAllBookIds();

  for (const bookId of bookIds) {
    const manifest = getBookManifest(bookId);
    if (manifest) {
      for (const chapterRef of manifest.chapters) {
        const chapter = getChapter(bookId, chapterRef.file);
        if (chapter) {
          chapters.push({
            bookId,
            chapterId: chapterRef.id,
            title: chapter.title,
            summary: chapter.summary,
            keyIdeas: chapter.keyIdeas || [],
          });
        }
      }
    }
  }

  return chapters;
}

function extractKeywords(text: string): string[] {
  // Simple keyword extraction (in production, use NLP)
  const words = text
    .toLowerCase()
    .replace(/[^\w\s]/g, " ")
    .split(/\s+/)
    .filter((w) => w.length > 4 && !isStopWord(w));
  
  // Return unique words
  return Array.from(new Set(words)).slice(0, 5);
}

function isStopWord(word: string): boolean {
  const stopWords = new Set([
    "the", "a", "an", "and", "or", "but", "in", "on", "at", "to", "for",
    "of", "with", "by", "from", "this", "that", "these", "those",
  ]);
  return stopWords.has(word);
}

function generateCardRecommendation(card: MemoryCard): string {
  if (card.ease < 1.5) {
    return "This concept needs intensive review. Study it daily until ease improves.";
  } else if (card.ease < 2.0) {
    return "Review this concept more frequently to strengthen retention.";
  }
  return "Continue regular reviews to maintain mastery.";
}

function generateFallacyRecommendation(
  type: string,
  fallacies: any[]
): string {
  const fallacy = fallacies.find((f) => f.id === type || f.name === type);
  if (fallacy) {
    return `Study the ${fallacy.name} fallacy: ${fallacy.description}`;
  }
  return `Review logical fallacies, particularly ${type}`;
}

function generatePuzzleRecommendation(type: string): string {
  return `Practice more ${type} puzzles to improve your reasoning skills`;
}
