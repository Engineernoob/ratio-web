/**
 * Memory AI - Scheduler
 *
 * Handles background jobs for periodic analysis and updates
 */

import fs from "fs";
import path from "path";
import { curateInsights } from "./curator";
import type { InsightSummary } from "./curator";

const DATA_DIR = path.join(process.cwd(), "data");
const MEMORY_AI_DIR = path.join(DATA_DIR, "memory-ai");
const SCHEDULE_FILE = path.join(MEMORY_AI_DIR, "schedule.json");

interface ScheduleState {
  lastRun: string | null;
  nextRun: string | null;
  runCount: number;
  lastResult: InsightSummary | null;
  errors: Array<{
    timestamp: string;
    error: string;
  }>;
}

/**
 * Initialize scheduler state
 */
function initializeSchedule(): ScheduleState {
  if (fs.existsSync(SCHEDULE_FILE)) {
    try {
      const data = fs.readFileSync(SCHEDULE_FILE, "utf-8");
      return JSON.parse(data);
    } catch (error) {
      console.error("Error loading schedule state:", error);
    }
  }

  return {
    lastRun: null,
    nextRun: null,
    runCount: 0,
    lastResult: null,
    errors: [],
  };
}

/**
 * Save scheduler state
 */
function saveSchedule(state: ScheduleState): void {
  try {
    if (!fs.existsSync(MEMORY_AI_DIR)) {
      fs.mkdirSync(MEMORY_AI_DIR, { recursive: true });
    }
    fs.writeFileSync(SCHEDULE_FILE, JSON.stringify(state, null, 2), "utf-8");
  } catch (error) {
    console.error("Error saving schedule state:", error);
  }
}

/**
 * Run scheduled analysis
 * This can be called manually or by a cron job
 */
export async function runScheduledAnalysis(): Promise<InsightSummary> {
  const state = initializeSchedule();
  const now = new Date().toISOString();

  try {
    console.log("Running scheduled memory AI analysis...");

    // Run curation
    const insights = await curateInsights();

    // Update state
    state.lastRun = now;
    state.nextRun = getNextRunTime();
    state.runCount += 1;
    state.lastResult = insights;

    // Save state
    saveSchedule(state);

    console.log(
      `Analysis complete. Generated ${insights.autoGeneratedCards} new cards.`
    );

    return insights;
  } catch (error: any) {
    // Record error
    state.errors.push({
      timestamp: now,
      error: error.message,
    });

    // Keep only last 10 errors
    if (state.errors.length > 10) {
      state.errors = state.errors.slice(-10);
    }

    saveSchedule(state);
    throw error;
  }
}

/**
 * Get next scheduled run time (24 hours from now)
 */
function getNextRunTime(): string {
  const next = new Date();
  next.setHours(next.getHours() + 24);
  return next.toISOString();
}

/**
 * Check if analysis should run (based on schedule)
 */
export function shouldRunAnalysis(): boolean {
  const state = initializeSchedule();

  if (!state.nextRun) {
    return true; // Never run before
  }

  const now = new Date();
  const nextRun = new Date(state.nextRun);

  return now >= nextRun;
}

/**
 * Get schedule status
 */
export function getScheduleStatus(): ScheduleState {
  return initializeSchedule();
}

/**
 * Manual trigger for testing
 */
export async function triggerAnalysis(): Promise<InsightSummary> {
  return runScheduledAnalysis();
}
